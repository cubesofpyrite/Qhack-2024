                
# Write any helper functions you need
def S(phi):
    return np.array([
        [np.exp(1j * phi), 0],
        [0, np.exp(-1j * phi)]
    ])

def U(a):
    b = np.sqrt(1 - a**2)
    return np.array([
        [a, b],
        [b, -a]
    ])
def coefficients(angles):
    
    """ This function returns the coefficients associated with the polynomial generated by 
    the QSP routine as a function of the phase angles.
    
    Args:
        - angles (np.array(float)): Array of real numbers containing the four phase angles,
        in reverse order of application.
    
    Returns:       
        - (np.array(complex)): A numpy array containing the coefficients of the polynomial
        generated by QSP, where the first element is the coefficient of the cubic term and
        the second element is for the linear term.
    """
    

    # Put your code here
    def P(a):
        circuit_U = S(angles[3]) @ U(a) @ S(angles[2]) @ U(a) @ S(angles[1]) @ U(a) @ S(angles[0])
        return circuit_U[0][0]

    alpha = (P(1) - 2*P(0.5)) * (4 / 3)
    beta = (P(1) - 8*P(0.5)) / (-3)
    
    return np.array([alpha, beta])
# These functions are responsible for testing the solution.


def run(test_case_input: str) -> str:
    ins = np.array(json.loads(test_case_input))
    coeffs = coefficients(ins)
    outs = [[np.real(elem).numpy(), np.imag(elem).numpy()] for elem in coeffs]
    
    return str(outs)


def check(solution_output: str, expected_output: str) -> None:
    solution_output = json.loads(solution_output)
    expected_output = json.loads(expected_output)

    assert np.allclose(solution_output, expected_output, rtol = 1e-4)
